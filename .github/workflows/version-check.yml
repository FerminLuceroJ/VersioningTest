name: Terraform Module Version Checker

on:
#  push:
#    branches:
#      - main
  workflow_dispatch:
  #schedule:
    ##- cron: '0 10 * * *'  # Todos los d√≠as a las 7AM Argentina

permissions:
  contents: read
  issues: write

jobs:

  # ===============================================
  # JOB 1: Version Checker
  # (1) Parse modules.plain
  # (2) Query the Registry and compare versions
  # (3) Save comparisons in version_report.md
  # (4) Outdated modules go to module_issues.txt
  # (5) Upload module_issues.txt as an Artifact
  # ===============================================


  check_versions:
    runs-on: ubuntu-latest
    outputs:
      outdated: ${{ steps.check.outputs.outdated }}

    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üõ†Ô∏è Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: latest

      - name: üèóÔ∏è Generar listado de m√≥dulos
        run: |
          cd example/complete
          terraform init -input=false -backend=false > /dev/null
          terraform modules > modules.plain

      - name: üöÄ Run version checker
        id: check
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          INPUT_FILE="example/complete/modules.plain"
          OUTPUT_FILE="version_report.md"
          TMP_FILE=".modules_cleaned.tmp"
          ISSUE_FILE="module_issues.txt"

          if [[ ! -f "$INPUT_FILE" ]]; then
            echo "‚ùå No existe $INPUT_FILE. Abortando."
            exit 1
          fi


          # ========== (1) Extract relevant fields: module_name, path, version ==========
          sed -nE 's/.*"([^"]+)"\[([^]]+)\][[:space:]]+([0-9]+\.[0-9]+\.[0-9]+).*$/\1|\2|\3/p' "$INPUT_FILE" > "$TMP_FILE"

          # ========== BEGIN version_report.md file ==========
          echo "# üì¶ Terraform Module Version Report" > "$OUTPUT_FILE"
          echo "_Generated on $(date)_" >> "$OUTPUT_FILE"
          echo "" >> "$OUTPUT_FILE"
          touch "$ISSUE_FILE"

          # ========== (2) VERSION QUERY and COMPARISON ==========
          while IFS="|" read -r MODULE_NAME MODULE_PATH USED_VERSION; do
            MODULE_NAME=$(echo "$MODULE_NAME" | sed 's/^module\.//; s/ *$//')
            MODULE_PATH=$(echo "$MODULE_PATH" | xargs)
            USED_VERSION=$(echo "$USED_VERSION" | xargs | sed 's/^[^0-9]*//')

            if [[ -z "$MODULE_PATH" || "$MODULE_PATH" != registry.terraform.io/* ]]; then
              continue
            fi

             # Extract namespace, name, and provider without removing submodules
            MODULE_INFO=$(echo "$MODULE_PATH" | sed 's|^registry\.terraform\.io/||' | cut -d/ -f1-3)
            IFS='/' read -r namespace name provider <<< "$MODULE_INFO"

            if [[ -z "$namespace" || -z "$name" || -z "$provider" ]]; then
              echo "‚ö†Ô∏è Entrada malformada: $MODULE_PATH" | tee -a "$OUTPUT_FILE"
              continue
            fi

            API_URL="https://registry.terraform.io/v1/modules/${namespace}/${name}/${provider}/versions"
            RESPONSE=$(curl -s "$API_URL")

            if [[ -z "$RESPONSE" || "$RESPONSE" == "null" ]]; then
              echo "‚ö†Ô∏è No se pudo obtener la √∫ltima versi√≥n de \`${MODULE_PATH}\` (error API)" | tee -a "$OUTPUT_FILE"
              continue
            fi

            LATEST_VERSION=$(echo "$RESPONSE" | jq -r '.modules[0].versions | map(.version) | sort | last')

            if [[ -z "$LATEST_VERSION" || "$LATEST_VERSION" == "null" ]]; then
              echo "‚ö†Ô∏è No se pudo determinar la √∫ltima versi√≥n de \`${MODULE_PATH}\`" | tee -a "$OUTPUT_FILE"
              continue
            fi

            # ========== (3) Write result to version_report.md ==========
            if [[ "$USED_VERSION" == "$LATEST_VERSION" ]]; then
              echo "‚úÖ \`${MODULE_PATH}\` est√° actualizado (**$USED_VERSION**)" | tee -a "$OUTPUT_FILE"
            else
              echo "‚ùå \`${MODULE_PATH}\` est√° desactualizado (usado: **$USED_VERSION**, √∫ltimo: **$LATEST_VERSION**)" | tee -a "$OUTPUT_FILE"
              
              # ========== (4) Save outdated module to module_issues.txt ==========
              echo "${MODULE_NAME}|${namespace}/${name}/${provider}|${USED_VERSION}|${LATEST_VERSION}" >> "$ISSUE_FILE"
            fi
          done < "$TMP_FILE"

          rm -f "$TMP_FILE"

            # ========== Output to trigger the second job ==========
          if [[ -s "$ISSUE_FILE" ]]; then
            echo "outdated=true" >> "$GITHUB_OUTPUT"
          else
            echo "outdated=false" >> "$GITHUB_OUTPUT"
          fi

      
      ##- name: üìù Listar archivos antes de subir artifact
      ##  run: ls -lh . || true

      - name: üìÑ Mostrar contenido de module_issues.txt
        run: cat module_issues.txt || echo "Archivo vac√≠o o no existe"


      # ========== (5) Upload the generated files as artifacts ========== 
             
      - name: üì¶ Guardar artifacts
        if: ${{ steps.check.outputs.outdated == 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: module-version-check
          path: module_issues.txt  

  # ======================================================
  # JOB 2: Issue Generator
  # (1) Reads module_issues.txt generated by the previous job
  # (2) For each module, checks if there's already an open issue
  # (3) If it doesn't exist -> creates it
  # (4) If it exists but is outdated -> updates it
  # ======================================================

  manage_issues:
    needs: check_versions
    if: needs.check_versions.outputs.outdated == 'true'
    runs-on: ubuntu-latest

    steps:

      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üì• Descargar artifacts del job anterior
        uses: actions/download-artifact@v4
        with:
          name: module-version-check
          path: module-version-check 

      - name: üè∑Ô∏è Asegurar existencia del label 'terraform'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh label list | grep -q '^terraform' || \
          gh label create terraform --description "Issues relacionados con m√≥dulos de Terraform" --color 623CE4    

      - name: üêõ Crear o actualizar issues para m√≥dulos desactualizados
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |

          # ========== (1) Iterate through each outdated module ==========
          while IFS="|" read -r pattern module used latest; do
            title="Upgrade(${pattern}): ${module} (${used} > ${latest})"

            # ========== (2) Check if an issue already exists ==========
            echo "üîç Buscando issue existente para $pattern"
            issue_data=$(gh issue list --state open --json title,number --jq \
              '.[] | select(.title | startswith("Upgrade('"$pattern"'):"))')

            # ========== (3) If it doesn't exist, create the issue ==========
            if [[ -z "$issue_data" ]]; then              
              echo "üåü Creando issue: $title"
              gh issue create \
                --title "$title" \
                --body "El m√≥dulo \`${module}\` est√° desactualizado. - Pattern: \`${pattern}\` - Usando: \`${used}\` - √öltima versi√≥n: \`${latest}\`" \
                --label terraform
            else
              number=$(echo "$issue_data" | jq -r '.number')
              old_title=$(echo "$issue_data" | jq -r '.title')


              # ========== (4) Si existe pero est√° desactualizado, lo actualizo ==========
              if [[ "$old_title" != *"$latest"* ]]; then
                echo "‚úèÔ∏è Actualizando issue #$number con nueva versi√≥n"
                gh issue edit "$number" \
                  --title "$title" \
                  --body "El m√≥dulo \`${module}\` est√° desactualizado. - Pattern: \`${pattern}\` - Usando: \`${used}\` - √öltima versi√≥n: \`${latest}\`"
              else
                echo "‚úÖ Issue ya existente y actualizado para $pattern"
              fi
            fi
          done < module-version-check/module_issues.txt 